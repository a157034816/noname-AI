# 配置项与生效范围

本文面向玩家与开发者，解释本扩展的配置项（`slqj_ai_*`）、它们何时生效、以及为什么“修改后建议重启”。

> 代码 SSOT：配置项定义主要位于 `extension.js`；运行期读取主要位于 `src/ai_persona/index.js` 与 `src/ai_persona/selector_patch.js`、`src/scripts_loader.js`。

---

## 1) 生效范围（最重要的约束）

### 1.1 仅本地单机 AI
扩展中的“本地 AI 玩家”判定见 `src/ai_persona/lib/utils.js -> isLocalAIPlayer(player, game, _status)`：

- **非自机玩家**：`_status.connectMode === false` 且 `player.isOnline() === false`（联机连接模式/联机玩家直接跳过）
- **自机玩家（game.me）**：默认不算本地 AI；仅当自机处于托管（`player.isAuto===true`）时，才视为“本地 AI”（让托管按 AI 逻辑运行）

换句话说：扩展大部分行为只会影响“离线对局中的电脑玩家”；当你把自机切换为托管后，自机也会受影响（走同一套评分/策略/scripts 链路）。

### 1.2 身份局专属逻辑
以下模块仅在 `get.mode()==="identity"` 时运行：

- 行为证据（evidence）记录
- 身份猜测（guess identity）
- 软暴露与主公阵营线索（zhuSignal）
- 多数“保守门槛”（避免误伤/乱救/乱下延时锦囊）

---

## 2) 配置项总览（玩家可见）

扩展配置位于 `extension.js -> config`，其中多数配置会同时写入两个键：

- `extension_身临其境的AI_<key>`（扩展前缀键）
- `<key>`（无前缀键，例如 `slqj_ai_inspect_lang`）

这样做的目的：与无名杀扩展配置体系兼容，并与本扩展其他模块读取方式一致。

### 2.1 配置表

| 配置键 | UI 名称 | 默认值（UI） | 主要作用 | 主要读取位置 | 备注 |
|---|---|---:|---|---|---|
| `slqj_ai_inspect_lang` | AI标记用语 | `zh` | AI 面板文案语言（中/英） | `src/ai_persona/index.js`、`src/ai_persona/skills/persona_skills.js` | 修改后建议重启（面板 marktext/intro 依赖启动时读取） |
| `slqj_ai_inspect_enable` | 开局添加AI标记(Debug) | `false` | 开局是否给所有角色挂 `slqj_ai_inspect` 标记 | `src/ai_persona/skills/persona_skills.js` | 仅本地；配置项名含 Debug，但实际是“是否挂标记” |
| `slqj_ai_blind_handcard_random` | 盲选手牌随机化（反全知） | `true` | “看不见对方手牌”的选牌按钮随机化 | `src/ai_persona/selector_patch.js` | 只影响不可见手牌按钮；明牌/可观手牌仍走原逻辑 |
| `slqj_ai_score_noise_enable` | 评分噪声（仅冲动型） | `true` | 冲动型人格对正收益候选加入少量噪声 | `src/ai_persona/selector_patch.js` | 不会把 0/负收益抬成正收益（避免明显离谱） |
| `slqj_ai_persona_enable_balanced` | 启用人格：均衡（Balanced） | `true` | 开局随机人格候选开关（均衡） | `src/ai_persona/index.js`、`src/ai_persona/runtime/player_init.js` | 若全部人格都关闭，会兜底回退到均衡 |
| `slqj_ai_persona_enable_impulsive` | 启用人格：冲动（Impulsive） | `true` | 开局随机人格候选开关（冲动） | `src/ai_persona/index.js`、`src/ai_persona/runtime/player_init.js` | 同上 |
| `slqj_ai_persona_enable_petty` | 启用人格：记仇（Petty） | `true` | 开局随机人格候选开关（记仇） | `src/ai_persona/index.js`、`src/ai_persona/runtime/player_init.js` | 同上 |
| `slqj_ai_persona_enable_camouflage` | 启用人格：伪装（Camouflage） | `false` | 开局随机人格候选开关（伪装） | `src/ai_persona/index.js`、`src/ai_persona/runtime/player_init.js` | 默认关闭；仅身份局反贼压制前期对主公敌意 |
| `slqj_ai_scripts_enable` | 加载 scripts 插件 | `true` | 是否自动加载 `scripts/` 下脚本插件 | `src/scripts_loader.js` | 若关闭：`scripts/` 全部跳过加载 |
| `slqj_ai_scripts_registry` | （隐藏/由管理器维护） | 空 | scripts 插件启用/顺序注册表 | `src/scripts_registry.js` `src/scripts_loader.js` | 由“脚本插件管理”UI 保存 |
| `slqj_ai_scripts_config` | （隐藏/由配置弹窗维护） | 空 | scripts 插件配置覆盖值（按脚本文件名保存） | `src/scripts_config.js` `src/scripts_loader.js` | 由“脚本插件管理 -> 配置(⚙)”保存 |
| （无键） | 脚本插件管理 | - | 打开管理 UI（启用/禁用/排序/保存） | `src/scripts_manager_modal.js` | 保存后通常需重启生效 |
| （无键） | 加群 | - | 打开 QQ 群链接 | `extension.js` | 纯链接，无功能逻辑 |

> 说明：上表“默认值（UI）”来自 `extension.js` 的 `config.*.init`。人格系统安装时也有一套兜底默认值（见 `src/ai_persona/index.js`），但实际使用中通常以 UI init 的默认为准。

---

## 3) 为什么“修改后建议重启生效”？

本扩展的关键安装点发生在 `extension.js -> precontent(config)`：

- 人格系统与补丁只在扩展加载时安装一次（带 `installed` 防重复）
- scripts 插件加载器会在启动时枚举目录并按注册表顺序 `import()`，随后不会自动重新加载（除非你手动触发/重启）
- AI 标记技能 `slqj_ai_inspect` 的显示文案（语言）在安装全局技能时读取一次

因此当你修改配置项后，最稳妥的方式是重启客户端或重新载入扩展，使：

- `game.__slqjAiPersona.cfg` 重新生成
- 选择器补丁/态度补丁/默认策略 hooks 重新读取 cfg
- scripts loader 按新注册表重新 import

---

## 4) 开发者补充：调试开关与隐藏配置

### 4.1 `lib.config.dev`
当 `lib.config.dev === true` 时：

- `src/ai_persona/skills/persona_skills.js` 会暴露 `window.slqjAI.get(player)`，用于读取 `player.storage.slqj_ai`（仅调试）
- 若脚本插件内部读取 `lib.config.dev`，可能会输出更详细日志（例如热门选将脚本、铁索配合脚本等）

### 4.2 `slqj_ai_scripts_debug`
`src/ai_persona/lib/jsdoc_types.js` 中声明了 `slqj_ai_scripts_debug?: boolean`：

- 本扩展 UI 未提供该项
- 但部分脚本会读取它（例如 `scripts/01_popular_general_candidates.js` 的 logger）

如需在不打开 `dev` 的情况下让 scripts 更详细输出，可手动写入该键（具体写入方式取决于你的无名杀环境）。

### 4.3 日志系统（`src/logger/*`）
为便于统一控制输出与降低重复封装，本扩展的 **core 代码**（`extension.js` + `src/`）已将控制台输出集中到：

- `src/logger/console.js`：唯一的 console 输出入口（安全调用 + prefix + feature + 保留 `%s/%d` 格式化）
- `src/logger/manager.js`：按「名称」注册/获取 logger 实例（类注册）

约定与边界：

- core 代码中避免直接调用 `console.*`（允许 `src/logger/console.js` 内部使用）
- core 仅注册 **一个** logger：在 `extension.js -> precontent(config)` 中 `register("console", ConsoleLogger, {prefix, debug})`
- 其余模块统一 `get("console")` 获取实例，并通过 `feature` 区分来源（例如 `hook/scripts/update/modal/...`）
- `manager.get(name)` **不会**在未注册时隐式创建 logger：未 `register(name, 类)` 时返回 noop logger（不输出、不报错），避免影响运行
- core 统一输出签名：`logger.log/warn/error/debug(feature, ...args)`（功能名在前）
- `scripts/` 下的脚本插件属于“插件生态”，可继续自带 logger；不强制跟随 core 的 logger 体系
